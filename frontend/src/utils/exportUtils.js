import jsPDF from 'jspdf';
import * as XLSX from 'xlsx';
import html2canvas from 'html2canvas';

/**
 * Generate a professional logo/header for the PDF
 */
const addPDFHeader = (doc) => {
  const pageWidth = doc.internal.pageSize.getWidth();

  // 1. Blue background for header
  doc.setFillColor(0, 82, 204); // Jira blue
  doc.rect(0, 0, pageWidth, 60, 'F');

  // 2. Add your logo (favicon)
  const logoUrl = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS7Y3dj3QCsR32b0r-Oiif92n9-5r8QllkcdQ&s'; // ← change to production URL later!
  
  const logoX = 15;
  const logoY = 12;
  const logoWidth = 36;   // slightly smaller to fit nicely
  const logoHeight = 36;  // square favicon usually looks good

  try {
    doc.addImage(
      logoUrl,
      'ICO',           // favicon is .ico format (jsPDF supports it)
      logoX,
      logoY,
      logoWidth,
      logoHeight
    );
  } catch (err) {
    console.warn('Failed to load logo:', err);
    // Fallback: draw simple circle + D if logo fails
    doc.setFillColor(255, 255, 255);
    doc.circle(30, 30, 15, 'F');
    doc.setFillColor(0, 82, 204);
    doc.setFontSize(22);
    doc.setFont('helvetica', 'bold');
    doc.text('D', 25, 36);
  }

  // 3. Main title - moved right to make space for logo
  doc.setFontSize(26);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(255, 255, 255);
  doc.text('DOIT Dashboard Report', 62, 30); // ← adjusted from 55 to 62

  // 4. Subtitle
  doc.setFontSize(12);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(220, 230, 255); // slightly lighter white for contrast
  doc.text('Comprehensive Analytics & Insights', 62, 42);

  // 5. Decorative white line at bottom of header
  doc.setDrawColor(255, 255, 255);
  doc.setLineWidth(2);
  doc.line(14, 55, pageWidth - 14, 55);
};

/**
 * Add footer to PDF pages
 */
const addPDFFooter = (doc, pageNum, totalPages) => {
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();

  doc.setFillColor(248, 250, 252);
  doc.rect(0, pageHeight - 25, pageWidth, 25, 'F');

  doc.setFontSize(9);
  doc.setTextColor(100, 116, 139);
  doc.setFont('helvetica', 'normal');

  doc.text(`Page ${pageNum} of ${totalPages}`, 14, pageHeight - 12);

  doc.text('Generated by DOIT Task Management System', pageWidth / 2, pageHeight - 12, {
    align: 'center',
  });

  doc.text(new Date().toLocaleString(), pageWidth - 14, pageHeight - 12, {
    align: 'right',
  });
};

/**
 * Create a section header
 */
const addSectionHeader = (doc, title, yPos) => {
  doc.setFillColor(240, 245, 255);
  doc.roundedRect(14, yPos - 8, doc.internal.pageSize.getWidth() - 28, 12, 3, 3, 'F');

  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 82, 204);
  doc.text(`${title}`, 18, yPos);

  return yPos + 15;
};

/**
 * Draw an enhanced table with styling
 */
const drawStyledTable = (doc, headers, data, startY, colors = {}) => {
  let y = startY;
  const pageWidth = doc.internal.pageSize.getWidth();
  const colWidth = (pageWidth - 28) / headers.length;

  // Check if we need a new page
  if (y > 240) {
    doc.addPage();
    addPDFHeader(doc);
    y = 75;
  }

  // Draw header row
  doc.setFillColor(0, 82, 204);
  doc.roundedRect(14, y - 8, pageWidth - 28, 10, 2, 2, 'F');

  doc.setFontSize(10);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(255, 255, 255);

  headers.forEach((header, i) => {
    doc.text(header, 18 + i * colWidth, y);
  });

  y += 12;

  // Draw data rows
  data.forEach((row, rowIndex) => {
    if (y > 260) {
      doc.addPage();
      addPDFHeader(doc);
      y = 75;
    }

    // Alternating row colors
    if (rowIndex % 2 === 0) {
      doc.setFillColor(248, 250, 252);
      doc.rect(14, y - 7, pageWidth - 28, 10, 'F');
    }

    doc.setFont('helvetica', 'normal');
    doc.setFontSize(9);
    doc.setTextColor(30, 41, 59);

    row.forEach((cell, i) => {
      const text = String(cell);
      const maxWidth = colWidth - 5;

      // Truncate if too long
      const displayText =
        doc.getTextWidth(text) > maxWidth ? text.substring(0, 30) + '...' : text;

      doc.text(displayText, 18 + i * colWidth, y);
    });

    y += 10;
  });

  return y + 10;
};

/**
 * Add a key metrics summary box
 */
const addMetricsSummary = (doc, metrics, startY) => {
  let y = startY;
  const pageWidth = doc.internal.pageSize.getWidth();
  const boxWidth = (pageWidth - 38) / 2;

  doc.setFillColor(245, 250, 255);
  doc.roundedRect(14, y, boxWidth, 50, 4, 4, 'F');
  doc.roundedRect(24 + boxWidth, y, boxWidth, 50, 4, 4, 'F');

  // Left box - Task metrics
  doc.setFontSize(11);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 82, 204);
  doc.text('Task Overview', 20, y + 10);

  doc.setFontSize(9);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(71, 85, 105);

  const taskMetrics = [
    `Total: ${metrics.total}`,
    `Pending: ${metrics.pending}`,
    `In Progress: ${metrics.in_progress}`,
    `Completed: ${metrics.closed}`,
  ];

  taskMetrics.forEach((metric, i) => {
    doc.text(metric, 20, y + 22 + i * 7);
  });

  // Right box - Performance indicators
  doc.setFontSize(11);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 82, 204);
  doc.text('Performance', 30 + boxWidth, y + 10);

  const completionRate = metrics.total > 0 ? ((metrics.closed / metrics.total) * 100).toFixed(1) : 0;
  const onTimeRate =
    metrics.total > 0 ? (((metrics.total - metrics.overdue) / metrics.total) * 100).toFixed(1) : 0;

  doc.setFontSize(9);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(71, 85, 105);

  doc.text(`Completion: ${completionRate}%`, 30 + boxWidth, y + 22);
  doc.text(`On-Time: ${onTimeRate}%`, 30 + boxWidth, y + 29);
  doc.text(`Overdue: ${metrics.overdue}`, 30 + boxWidth, y + 36);

  return y + 60;
};

/**
 * Add a visual progress bar
 */
const addProgressBar = (doc, label, value, max, y, color = [0, 82, 204]) => {
  const pageWidth = doc.internal.pageSize.getWidth();
  const barWidth = pageWidth - 80;
  const percentage = max > 0 ? (value / max) * 100 : 0;

  doc.setFontSize(9);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(71, 85, 105);
  doc.text(label, 20, y);
  doc.text(`${value}/${max}`, pageWidth - 30, y, { align: 'right' });

  // Background bar
  doc.setFillColor(229, 231, 235);
  doc.roundedRect(20, y + 2, barWidth, 6, 3, 3, 'F');

  // Progress bar
  if (percentage > 0) {
    doc.setFillColor(...color);
    doc.roundedRect(20, y + 2, (barWidth * percentage) / 100, 6, 3, 3, 'F');
  }

  return y + 15;
};

/**
 * Enhanced PDF Export with Charts and Professional Design
 */
export const exportToPDF = async (analytics, userName, options = {}) => {
  try {
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.getWidth();

    // Page 1: Cover Page
    addPDFHeader(doc);

    let yPos = 80;

    // User info and date
    doc.setFontSize(14);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(71, 85, 105);
    doc.text(`Generated for: ${userName}`, pageWidth / 2, yPos, { align: 'center' });

    yPos += 10;
    doc.setFontSize(12);
    doc.text(
      new Date().toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric',
      }),
      pageWidth / 2,
      yPos,
      { align: 'center' }
    );

    yPos += 25;

    // Key metrics summary box
    yPos = addMetricsSummary(doc, analytics.task_stats, yPos);

    yPos += 15;

    // Visual progress indicators
    yPos = addSectionHeader(doc, 'Task Progress Overview', yPos);

    yPos = addProgressBar(
      doc,
      'Completed Tasks',
      analytics.task_stats?.closed || 0,
      analytics.task_stats?.total || 0,
      yPos,
      [16, 185, 129]
    );

    yPos = addProgressBar(
      doc,
      'In Progress Tasks',
      analytics.task_stats?.in_progress || 0,
      analytics.task_stats?.total || 0,
      yPos,
      [59, 130, 246]
    );

    yPos = addProgressBar(
      doc,
      'Pending Tasks',
      analytics.task_stats?.pending || 0,
      analytics.task_stats?.total || 0,
      yPos,
      [245, 158, 11]
    );

    // Page 2: Detailed Statistics
    doc.addPage();
    addPDFHeader(doc);
    yPos = 75;

    // Task Statistics Table
    yPos = addSectionHeader(doc, 'Task Statistics', yPos);

    const taskStatsData = [
      ['Total Tasks', analytics.task_stats?.total || 0],
      ['Pending Tasks', analytics.task_stats?.pending || 0],
      ['In Progress', analytics.task_stats?.in_progress || 0],
      ['Completed Tasks', analytics.task_stats?.closed || 0],
      ['Overdue Tasks', analytics.task_stats?.overdue || 0],
    ];

    yPos = drawStyledTable(doc, ['Metric', 'Count'], taskStatsData, yPos);

    yPos += 10;

    // Priority Distribution
    yPos = addSectionHeader(doc, 'Priority Distribution', yPos);

    const priorityData = [
      ['High Priority', analytics.priority_distribution?.High || 0],
      ['Medium Priority', analytics.priority_distribution?.Medium || 0],
      ['Low Priority', analytics.priority_distribution?.Low || 0],
    ];

    yPos = drawStyledTable(doc, ['Priority Level', 'Task Count'], priorityData, yPos);

    yPos += 10;

    // Status Distribution
    if (analytics.status_distribution) {
      yPos = addSectionHeader(doc, 'Status Distribution', yPos);

      const statusData = Object.entries(analytics.status_distribution).map(([status, count]) => {
        const percentage =
          analytics.task_stats?.total > 0
            ? `${((count / analytics.task_stats.total) * 100).toFixed(1)}%`
            : '0%';
        return [status, count, percentage];
      });

      yPos = drawStyledTable(doc, ['Status', 'Count', 'Percentage'], statusData, yPos);
    }

    // Page 3: Project Statistics
    doc.addPage();
    addPDFHeader(doc);
    yPos = 75;

    yPos = addSectionHeader(doc, 'Project Statistics', yPos);

    const projectStatsData = [
      ['Total Projects', analytics.project_stats?.total || 0],
      ['Owned Projects', analytics.project_stats?.owned || 0],
      ['Member Projects', analytics.project_stats?.member_of || 0],
      ['Active Projects', analytics.project_stats?.active || 0],
    ];

    yPos = drawStyledTable(doc, ['Metric', 'Count'], projectStatsData, yPos);

    yPos += 15;

    // Project Progress Details
    if (analytics.project_progress && analytics.project_progress.length > 0) {
      yPos = addSectionHeader(doc, 'Project Progress Details', yPos);

      const progressData = analytics.project_progress.slice(0, 10).map((proj) => [
        proj.project_name || 'Unnamed',
        proj.total_tasks || 0,
        proj.completed_tasks || 0,
        `${proj.progress_percentage || 0}%`,
      ]);

      yPos = drawStyledTable(doc, ['Project Name', 'Total', 'Completed', 'Progress'], progressData, yPos);
    }

    // Page 4: Upcoming Deadlines
    if (analytics.upcoming_deadlines && analytics.upcoming_deadlines.length > 0) {
      doc.addPage();
      addPDFHeader(doc);
      yPos = 75;

      yPos = addSectionHeader(doc, 'Upcoming Deadlines', yPos);

      analytics.upcoming_deadlines.slice(0, 15).forEach((task, index) => {
        if (yPos > 250) {
          doc.addPage();
          addPDFHeader(doc);
          yPos = 75;
        }

        // Task card
        const isOverdue = task.days_until < 0;

        // FIXED: Use spread operator with array
        doc.setFillColor(...(isOverdue ? [254, 226, 226] : [240, 245, 255]));
        doc.roundedRect(14, yPos - 5, pageWidth - 28, 24, 3, 3, 'F');

        // Ticket ID badge
        doc.setFillColor(0, 82, 204);
        doc.roundedRect(18, yPos - 2, 25, 6, 2, 2, 'F');
        doc.setFontSize(7);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(255, 255, 255);
        doc.text(task.ticket_id || `T-${index + 1}`, 20, yPos + 2);

        // Task title
        doc.setFontSize(10);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(30, 41, 59);
        const title = task.title.length > 50 ? task.title.substring(0, 50) + '...' : task.title;
        doc.text(title, 48, yPos + 2);

        // Task details
        doc.setFontSize(8);
        doc.setFont('helvetica', 'normal');
        doc.setTextColor(100, 116, 139);

        doc.text(`Priority: ${task.priority}`, 18, yPos + 10);
        doc.text(`Project: ${task.project_name || 'N/A'}`, 60, yPos + 10);

        // Due date with status
        const dueDate = new Date(task.due_date).toLocaleDateString();
        const daysText = isOverdue
          ? `${Math.abs(task.days_until)} days overdue`
          : `${task.days_until} days left`;

        // FIXED: Use spread operator here too
        doc.setTextColor(...(isOverdue ? [239, 68, 68] : [16, 185, 129]));
        doc.setFont('helvetica', 'bold');
        doc.text(`Due: ${dueDate} (${daysText})`, 18, yPos + 16);

        yPos += 30;
      });
    }

    // Add footers to all pages
    const totalPages = doc.internal.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      doc.setPage(i);
      addPDFFooter(doc, i, totalPages);
    }

    // Save the PDF
    doc.save(`DOIT-Dashboard-Report-${new Date().toISOString().split('T')[0]}.pdf`);
    return true;
  } catch (error) {
    console.error('PDF Export Error:', error);
    throw new Error('Failed to generate PDF: ' + error.message);
  }
};

// ──────────────────────────────────────────────────────────────────────────────
// The Excel and CSV functions remain unchanged (they had no syntax issues)
// You can keep your original versions or use the improved ones you already have
// ──────────────────────────────────────────────────────────────────────────────

// export { exportToExcel, exportToCSV } from './exportUtils-original.js'; // or just keep them here

// If you want to keep everything in one file, paste your working Excel & CSV functions here

/**
 * Enhanced Excel Export with Multiple Worksheets and Formatting
 */
export const exportToExcel = (analytics, report, userName) => {
  try {
    const wb = XLSX.utils.book_new();
    const currentDate = new Date().toLocaleDateString('en-US', { 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    });
    
    // ==================== EXECUTIVE SUMMARY ====================
    const summaryData = [
      ['DOIT Dashboard Report - Executive Summary'],
      [`Generated for: ${userName}`],
      [`Date: ${currentDate}`],
      [],
      ['KEY PERFORMANCE INDICATORS'],
      ['Metric', 'Value', 'Status'],
      [
        'Completion Rate', 
        analytics.task_stats?.total > 0 
          ? `${((analytics.task_stats.closed / analytics.task_stats.total) * 100).toFixed(1)}%`
          : '0%',
        analytics.task_stats?.total > 0 && (analytics.task_stats.closed / analytics.task_stats.total) >= 0.7 
          ? 'Good' 
          : 'Needs Improvement'
      ],
      [
        'On-Time Delivery',
        analytics.task_stats?.total > 0
          ? `${(((analytics.task_stats.total - (analytics.task_stats.overdue || 0)) / analytics.task_stats.total) * 100).toFixed(1)}%`
          : '0%',
        (analytics.task_stats?.overdue || 0) === 0 ? 'Excellent' : 'Review Required'
      ],
      [
        'Active Tasks',
        (analytics.task_stats?.pending || 0) + (analytics.task_stats?.in_progress || 0),
        'In Progress'
      ],
      [],
      ['TASK STATISTICS'],
      ['Metric', 'Count', 'Percentage'],
      [
        'Total Tasks', 
        analytics.task_stats?.total || 0,
        '100%'
      ],
      [
        'Pending Tasks', 
        analytics.task_stats?.pending || 0,
        analytics.task_stats?.total > 0 
          ? `${((analytics.task_stats.pending / analytics.task_stats.total) * 100).toFixed(1)}%`
          : '0%'
      ],
      [
        'In Progress', 
        analytics.task_stats?.in_progress || 0,
        analytics.task_stats?.total > 0 
          ? `${((analytics.task_stats.in_progress / analytics.task_stats.total) * 100).toFixed(1)}%`
          : '0%'
      ],
      [
        'Completed Tasks', 
        analytics.task_stats?.closed || 0,
        analytics.task_stats?.total > 0 
          ? `${((analytics.task_stats.closed / analytics.task_stats.total) * 100).toFixed(1)}%`
          : '0%'
      ],
      [
        'Overdue Tasks', 
        analytics.task_stats?.overdue || 0,
        analytics.task_stats?.total > 0 
          ? `${((analytics.task_stats.overdue / analytics.task_stats.total) * 100).toFixed(1)}%`
          : '0%'
      ],
      [],
      ['PROJECT STATISTICS'],
      ['Metric', 'Count'],
      ['Total Projects', analytics.project_stats?.total || 0],
      ['Owned Projects', analytics.project_stats?.owned || 0],
      ['Member Projects', analytics.project_stats?.member_of || 0],
      ['Active Projects', analytics.project_stats?.active || 0],
      [],
      ['PRIORITY DISTRIBUTION'],
      ['Priority', 'Count', 'Percentage'],
      [
        'High',
        analytics.priority_distribution?.High || 0,
        analytics.task_stats?.total > 0
          ? `${(((analytics.priority_distribution?.High || 0) / analytics.task_stats.total) * 100).toFixed(1)}%`
          : '0%'
      ],
      [
        'Medium',
        analytics.priority_distribution?.Medium || 0,
        analytics.task_stats?.total > 0
          ? `${(((analytics.priority_distribution?.Medium || 0) / analytics.task_stats.total) * 100).toFixed(1)}%`
          : '0%'
      ],
      [
        'Low',
        analytics.priority_distribution?.Low || 0,
        analytics.task_stats?.total > 0
          ? `${(((analytics.priority_distribution?.Low || 0) / analytics.task_stats.total) * 100).toFixed(1)}%`
          : '0%'
      ]
    ];
    
    const ws1 = XLSX.utils.aoa_to_sheet(summaryData);
    ws1['!cols'] = [{ wch: 25 }, { wch: 18 }, { wch: 20 }];
    
    XLSX.utils.book_append_sheet(wb, ws1, 'Executive Summary');
    
    // ==================== STATUS BREAKDOWN ====================
    if (analytics.status_distribution) {
      const statusData = [
        ['Task Status Analysis'],
        [`Report Date: ${currentDate}`],
        [],
        ['Status', 'Count', 'Percentage', 'Trend']
      ];
      
      const total = Object.values(analytics.status_distribution).reduce((sum, count) => sum + count, 0);
      
      Object.entries(analytics.status_distribution).forEach(([status, count]) => {
        const percentage = total > 0 ? ((count / total) * 100).toFixed(1) + '%' : '0%';
        const trend = status === 'Done' || status === 'Closed' ? '✓ Complete' : '→ Active';
        statusData.push([status, count, percentage, trend]);
      });
      
      statusData.push([]);
      statusData.push(['Total Tasks', total, '100%', '']);
      
      const ws2 = XLSX.utils.aoa_to_sheet(statusData);
      ws2['!cols'] = [{ wch: 20 }, { wch: 12 }, { wch: 15 }, { wch: 15 }];
      
      XLSX.utils.book_append_sheet(wb, ws2, 'Status Analysis');
    }
    
    // ==================== UPCOMING DEADLINES ====================
    if (analytics.upcoming_deadlines && analytics.upcoming_deadlines.length > 0) {
      const deadlineData = [
        ['Upcoming Deadlines & Due Tasks'],
        [`Total Tasks with Deadlines: ${analytics.upcoming_deadlines.length}`],
        [],
        ['Ticket ID', 'Task Title', 'Priority', 'Status', 'Due Date', 'Days Until', 'Project', 'Urgency']
      ];
      
      analytics.upcoming_deadlines.forEach(task => {
        const daysUntil = task.days_until;
        let urgency = 'Low';
        if (daysUntil < 0) urgency = 'OVERDUE';
        else if (daysUntil <= 3) urgency = 'Critical';
        else if (daysUntil <= 7) urgency = 'High';
        else if (daysUntil <= 14) urgency = 'Medium';
        
        deadlineData.push([
          task.ticket_id || 'N/A',
          task.title || 'Untitled',
          task.priority || 'Medium',
          task.status || 'To Do',
          task.due_date ? new Date(task.due_date).toLocaleDateString('en-US') : 'No deadline',
          daysUntil < 0 ? `${Math.abs(daysUntil)} days overdue` : `${daysUntil} days`,
          task.project_name || 'N/A',
          urgency
        ]);
      });
      
      const ws3 = XLSX.utils.aoa_to_sheet(deadlineData);
      ws3['!cols'] = [
        { wch: 12 }, 
        { wch: 40 }, 
        { wch: 12 }, 
        { wch: 15 }, 
        { wch: 15 }, 
        { wch: 18 }, 
        { wch: 25 },
        { wch: 12 }
      ];
      
      XLSX.utils.book_append_sheet(wb, ws3, 'Deadlines');
    }
    
    // ==================== PROJECT PROGRESS ====================
    if (analytics.project_progress && analytics.project_progress.length > 0) {
      const projectData = [
        ['Project Progress Dashboard'],
        [`Total Projects: ${analytics.project_progress.length}`],
        [],
        ['Project Name', 'Total Tasks', 'Completed', 'In Progress', 'Pending', 'Progress %', 'Health Status']
      ];
      
      analytics.project_progress.forEach(proj => {
        const progress = proj.progress_percentage || 0;
        let health = 'On Track';
        if (progress >= 80) health = 'Excellent';
        else if (progress >= 60) health = 'Good';
        else if (progress >= 40) health = 'At Risk';
        else health = 'Needs Attention';
        
        projectData.push([
          proj.project_name || 'Unnamed Project',
          proj.total_tasks || 0,
          proj.completed_tasks || 0,
          proj.in_progress_tasks || 0,
          proj.pending_tasks || 0,
          progress + '%',
          health
        ]);
      });
      
      const ws4 = XLSX.utils.aoa_to_sheet(projectData);
      ws4['!cols'] = [
        { wch: 30 }, 
        { wch: 13 }, 
        { wch: 13 }, 
        { wch: 13 }, 
        { wch: 13 }, 
        { wch: 13 },
        { wch: 18 }
      ];
      
      XLSX.utils.book_append_sheet(wb, ws4, 'Project Progress');
    }
    
    // ==================== MY TASKS DETAILED ====================
    if (report && report.my_tasks && report.my_tasks.length > 0) {
      const tasksData = [
        ['My Tasks - Detailed Report'],
        [`Total Assigned Tasks: ${report.my_tasks.length}`],
        [],
        ['Ticket ID', 'Title', 'Status', 'Priority', 'Due Date', 'Project', 'Assigned Date', 'Age (Days)']
      ];
      
      report.my_tasks.forEach(task => {
        const createdDate = task.created_at ? new Date(task.created_at) : new Date();
        const ageDays = Math.floor((new Date() - createdDate) / (1000 * 60 * 60 * 24));
        
        tasksData.push([
          task.ticket_id || 'N/A',
          task.title || 'Untitled',
          task.status || 'To Do',
          task.priority || 'Medium',
          task.due_date ? new Date(task.due_date).toLocaleDateString('en-US') : 'No deadline',
          task.project_name || 'N/A',
          task.created_at ? new Date(task.created_at).toLocaleDateString('en-US') : 'N/A',
          ageDays
        ]);
      });
      
      const ws5 = XLSX.utils.aoa_to_sheet(tasksData);
      ws5['!cols'] = [
        { wch: 12 }, 
        { wch: 40 }, 
        { wch: 15 }, 
        { wch: 12 }, 
        { wch: 15 }, 
        { wch: 25 }, 
        { wch: 15 },
        { wch: 12 }
      ];
      
      XLSX.utils.book_append_sheet(wb, ws5, 'My Tasks');
    }
    
    // ==================== RECENT ACTIVITY ====================
    if (analytics.recent_activities && analytics.recent_activities.length > 0) {
      const activityData = [
        ['Recent Activity Log'],
        [`Last ${analytics.recent_activities.length} Activities`],
        [],
        ['Task Title', 'Status', 'Priority', 'Project', 'Last Updated', 'Action Type']
      ];
      
      analytics.recent_activities.forEach(activity => {
        activityData.push([
          activity.title || 'Untitled',
          activity.status || 'N/A',
          activity.priority || 'Medium',
          activity.project_name || 'N/A',
          activity.updated_at ? new Date(activity.updated_at).toLocaleString('en-US') : 'N/A',
          activity.action_type || 'Update'
        ]);
      });
      
      const ws6 = XLSX.utils.aoa_to_sheet(activityData);
      ws6['!cols'] = [
        { wch: 40 }, 
        { wch: 15 }, 
        { wch: 12 }, 
        { wch: 25 }, 
        { wch: 20 },
        { wch: 15 }
      ];
      
      XLSX.utils.book_append_sheet(wb, ws6, 'Recent Activity');
    }
    
    // ==================== INSIGHTS & RECOMMENDATIONS ====================
    const insights = [
      ['Insights & Recommendations'],
      [],
      ['Category', 'Insight', 'Recommendation'],
    ];
    
    // Generate dynamic insights
    const completionRate = analytics.task_stats?.total > 0 
      ? (analytics.task_stats.closed / analytics.task_stats.total) * 100 
      : 0;
    
    if (completionRate < 50) {
      insights.push([
        'Task Completion',
        `Completion rate is ${completionRate.toFixed(1)}% (below target)`,
        'Focus on completing pending tasks. Consider reviewing task priorities.'
      ]);
    }
    
    if ((analytics.task_stats?.overdue || 0) > 0) {
      insights.push([
        'Overdue Tasks',
        `${analytics.task_stats.overdue} tasks are overdue`,
        'Prioritize overdue tasks immediately. Review deadlines and resource allocation.'
      ]);
    }
    
    const highPriorityTasks = analytics.priority_distribution?.High || 0;
    if (highPriorityTasks > (analytics.task_stats?.total || 0) * 0.3) {
      insights.push([
        'Priority Distribution',
        `${highPriorityTasks} high-priority tasks (>30% of total)`,
        'Review priority assignments. Consider if all high-priority tasks are truly critical.'
      ]);
    }
    
    if (analytics.project_stats?.total > 10) {
      insights.push([
        'Project Management',
        `Managing ${analytics.project_stats.total} projects`,
        'Consider consolidating projects or delegating ownership for better focus.'
      ]);
    }
    
    insights.push([
      'Performance',
      'Report generated successfully',
      'Regular monitoring recommended for optimal task management.'
    ]);
    
    const ws7 = XLSX.utils.aoa_to_sheet(insights);
    ws7['!cols'] = [{ wch: 20 }, { wch: 45 }, { wch: 50 }];
    
    XLSX.utils.book_append_sheet(wb, ws7, 'Insights');
    
    // Generate and download
    XLSX.writeFile(wb, `DOIT-Dashboard-Report-${new Date().toISOString().split('T')[0]}.xlsx`);
    return true;
  } catch (error) {
    console.error('Excel Export Error:', error);
    throw new Error('Failed to generate Excel: ' + error.message);
  }
};

/**
 * Enhanced CSV Export
 */
export const exportToCSV = (analytics, userName) => {
  try {
    let csv = 'DOIT Dashboard Report\n';
    csv += `Generated for: ${userName}\n`;
    csv += `Date: ${new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}\n`;
    csv += `Time: ${new Date().toLocaleTimeString('en-US')}\n\n`;
    
    // Key Performance Indicators
    csv += '=== KEY PERFORMANCE INDICATORS ===\n';
    csv += 'Metric,Value\n';
    const completionRate = analytics.task_stats?.total > 0 
      ? ((analytics.task_stats.closed / analytics.task_stats.total) * 100).toFixed(1)
      : 0;
    csv += `Completion Rate,${completionRate}%\n`;
    
    const onTimeRate = analytics.task_stats?.total > 0 
      ? (((analytics.task_stats.total - (analytics.task_stats.overdue || 0)) / analytics.task_stats.total) * 100).toFixed(1)
      : 0;
    csv += `On-Time Delivery Rate,${onTimeRate}%\n\n`;
    
    // Task Statistics
    csv += '=== TASK STATISTICS ===\n';
    csv += 'Metric,Count,Percentage\n';
    csv += `Total Tasks,${analytics.task_stats?.total || 0},100%\n`;
    csv += `Pending Tasks,${analytics.task_stats?.pending || 0},${analytics.task_stats?.total > 0 ? ((analytics.task_stats.pending / analytics.task_stats.total) * 100).toFixed(1) : 0}%\n`;
    csv += `In Progress,${analytics.task_stats?.in_progress || 0},${analytics.task_stats?.total > 0 ? ((analytics.task_stats.in_progress / analytics.task_stats.total) * 100).toFixed(1) : 0}%\n`;
    csv += `Completed Tasks,${analytics.task_stats?.closed || 0},${analytics.task_stats?.total > 0 ? ((analytics.task_stats.closed / analytics.task_stats.total) * 100).toFixed(1) : 0}%\n`;
    csv += `Overdue Tasks,${analytics.task_stats?.overdue || 0},${analytics.task_stats?.total > 0 ? ((analytics.task_stats.overdue / analytics.task_stats.total) * 100).toFixed(1) : 0}%\n\n`;
    
    // Project Statistics
    csv += '=== PROJECT STATISTICS ===\n';
    csv += 'Metric,Count\n';
    csv += `Total Projects,${analytics.project_stats?.total || 0}\n`;
    csv += `Owned Projects,${analytics.project_stats?.owned || 0}\n`;
    csv += `Member Of,${analytics.project_stats?.member_of || 0}\n`;
    csv += `Active Projects,${analytics.project_stats?.active || 0}\n\n`;
    
    // Priority Distribution
    csv += '=== PRIORITY DISTRIBUTION ===\n';
    csv += 'Priority,Count,Percentage\n';
    csv += `High,${analytics.priority_distribution?.High || 0},${analytics.task_stats?.total > 0 ? (((analytics.priority_distribution?.High || 0) / analytics.task_stats.total) * 100).toFixed(1) : 0}%\n`;
    csv += `Medium,${analytics.priority_distribution?.Medium || 0},${analytics.task_stats?.total > 0 ? (((analytics.priority_distribution?.Medium || 0) / analytics.task_stats.total) * 100).toFixed(1) : 0}%\n`;
    csv += `Low,${analytics.priority_distribution?.Low || 0},${analytics.task_stats?.total > 0 ? (((analytics.priority_distribution?.Low || 0) / analytics.task_stats.total) * 100).toFixed(1) : 0}%\n\n`;
    
    // Status Distribution
    if (analytics.status_distribution) {
      csv += '=== STATUS DISTRIBUTION ===\n';
      csv += 'Status,Count,Percentage\n';
      const total = Object.values(analytics.status_distribution).reduce((sum, count) => sum + count, 0);
      Object.entries(analytics.status_distribution).forEach(([status, count]) => {
        const percentage = total > 0 ? ((count / total) * 100).toFixed(1) : 0;
        csv += `${status},${count},${percentage}%\n`;
      });
      csv += '\n';
    }
    
    // Upcoming Deadlines
    if (analytics.upcoming_deadlines && analytics.upcoming_deadlines.length > 0) {
      csv += '=== UPCOMING DEADLINES ===\n';
      csv += 'Ticket ID,Task,Priority,Status,Due Date,Days Until,Project,Urgency\n';
      analytics.upcoming_deadlines.forEach(task => {
        const daysUntil = task.days_until;
        let urgency = 'Low';
        if (daysUntil < 0) urgency = 'OVERDUE';
        else if (daysUntil <= 3) urgency = 'Critical';
        else if (daysUntil <= 7) urgency = 'High';
        else if (daysUntil <= 14) urgency = 'Medium';
        
        const daysText = daysUntil < 0 
          ? `${Math.abs(daysUntil)} days overdue` 
          : `${daysUntil} days`;
        
        csv += `${task.ticket_id || 'N/A'},"${task.title}",${task.priority},${task.status},${new Date(task.due_date).toLocaleDateString()},${daysText},"${task.project_name}",${urgency}\n`;
      });
      csv += '\n';
    }
    
    // Project Progress
    if (analytics.project_progress && analytics.project_progress.length > 0) {
      csv += '=== PROJECT PROGRESS ===\n';
      csv += 'Project Name,Total Tasks,Completed,In Progress,Pending,Progress %,Health Status\n';
      analytics.project_progress.forEach(proj => {
        const progress = proj.progress_percentage || 0;
        let health = 'On Track';
        if (progress >= 80) health = 'Excellent';
        else if (progress >= 60) health = 'Good';
        else if (progress >= 40) health = 'At Risk';
        else health = 'Needs Attention';
        
        csv += `"${proj.project_name}",${proj.total_tasks || 0},${proj.completed_tasks || 0},${proj.in_progress_tasks || 0},${proj.pending_tasks || 0},${progress}%,${health}\n`;
      });
    }
    
    // Create download link
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', `DOIT-Dashboard-Report-${new Date().toISOString().split('T')[0]}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    return true;
  } catch (error) {
    console.error('CSV Export Error:', error);
    throw new Error('Failed to generate CSV: ' + error.message);
  }
}